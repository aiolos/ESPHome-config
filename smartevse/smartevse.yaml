esphome:
  name: smartevse
  friendly_name: smartevse

esp32:
  board: lolin_s2_mini
  variant: ESP32S2
  framework:
    type: esp-idf

# Enable logging
logger:
  baud_rate: 0 # Disable logging over UART
  level: DEBUG # NONE, ERROR, WARN, INFO, DEBUG (default), VERBOSE, VERY_VERBOSE

# Enable Home Assistant API
api:

ota:
  platform: esphome
  password: !secret ota_password

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

captive_portal:

##################################################################
external_components:
  - source:
      type: local
      path: components

uart:
  - id: uart_modbus_server
    baud_rate: 1200
    parity: NONE
    stop_bits: 1
    rx_pin: GPIO9
    tx_pin: GPIO11

modbus:
  - uart_id: uart_modbus_server
    id: modbus_server
    flow_control_pin: GPIO7
    disable_crc: true

modbus_controller:
  - modbus_id: modbus_server
    id: mb_controller
    address: 0x0A # Sensorbox is 0x0A / 10
    update_interval: 3s
    max_cmd_retries: 1

number:
  - platform: homeassistant
    id: evse_sensorbox_current
    entity_id: input_number.evse_sensorbox_current

switch:
  - platform: output
    name: "Generic Output"
    output: 'rs485_sensorbox_readings'

output:
  - platform: modbus_controller
    modbus_controller_id: mb_controller
    id: rs485_sensorbox_readings
    address: 0x7EFF
    register_type: coil
    write_lambda: |-
      ESP_LOGD("Sensorbox Simulator:", "Received value: %f", id(evse_sensorbox_current).state );
      float chargeCurrent = id(evse_sensorbox_current).state / 3 * 10;
      char ctValues[4];
      char* pBytes = (char*)&chargeCurrent; // Get its bytes
      // Copy the 4 bytes of the scaled float back to the buffer
      ctValues[0] = *pBytes++;
      ctValues[1] = *pBytes++;
      ctValues[2] = *pBytes++;
      ctValues[3] = *pBytes;
      char ctMeasurement[] = { 
        0xFF,       // Address Field = ff 
        0x03,       // Control Field = 03
        0x50, 0x01, // Protocol = 5001
        0x01,       // Version = 01
        0x03,       // Number of CTs = 3
        ctValues[0], ctValues[1], ctValues[2], ctValues[3],
        ctValues[0], ctValues[1], ctValues[2], ctValues[3],
        ctValues[0], ctValues[1], ctValues[2], ctValues[3]
      };
      unsigned int ctCrc = id(smartevsecrc)->CRC16(ctMeasurement, sizeof(ctMeasurement));
      unsigned char crc1 = ((unsigned char)(ctCrc));
      unsigned char crc2 = ((unsigned char)(ctCrc>>8));
      ESP_LOGD("Sensorbox Simulator: ", "CRC 0x%02X  0x%02X  0x%02X ", ctCrc, crc1, crc2 );
      ESP_LOGD("Sensorbox Simulator: ", "Current: 0x%02X - 0x%02X - 0x%02X - 0x%02X ", ctValues[0], ctValues[1], ctValues[2], ctValues[3] );
      
      payload.push_back(0x7E); // Start character
      for (int i = 0; i < sizeof(ctMeasurement); i++) {
        payload.push_back(ctMeasurement[i]);
      }
      payload.push_back(crc1);
      payload.push_back(crc2);
      payload.push_back(0x7E); // End character
      return false;

smartevse_crc:
  id: smartevsecrc

sensor:
  # Show value of charging current received from HA
  - platform: template
    name: evse sensorbox current received
    unit_of_measurement: 'A'
    lambda: |-
      ESP_LOGD("Template Sensor Lambda","Got new data: %f", id(evse_sensorbox_current).state);
      id(rs485_sensorbox_readings).turn_on();
      
      return { id(evse_sensorbox_current).state };
    update_interval: 3s
